#include<iostream>


//宏提供了一种机制，能够使你在编译期替换代码中的符号或者语句。当你的代码中存在大量相似的、重复的代码时，使用宏可以极大的减少代码量，便于书写。
//因为在预编译的时候文本展开，假如定义较为复杂的宏，程序调试的难度会提高

#define PI 3.1415926 
//使用宏作为常量的定义

#define MUL(x, y)  x*y
//由于宏是文本复制替换，因此此处并不需要 “；”
//宏是简单的符号替换，不会检查参数类型，而函数会严格检查输入的参数类型


#define STRING(x) #x
//#符号把一个宏参数直接转换为字符串

#define VAR(index) INT_##index
int VAR(1);
//宏被展开后将成为 int INT_1;
//##符号会连接两边的值，像一个粘合剂一样，将前后两部分粘合起来，从而产生一个新的值



#ifdef _WIN32
#endif

//#ifdef之后的宏只要定义过就会满足条件

#if defined(PI)
#endif //#if则会看后面的宏的内容是否为真了


#ifndef __SYSTEM_API_H__
#define __SYSTEM_API_H__
#endif //在C、C++中如果重复包含了同一个头文件，有可能会带来编译错误，所以我们应当避免这种事情发生，利用预处理指令和宏可以有效防止此类错误发生。
//第一次包含此文件时，__SYSTEM_API_H__还没有被定义，
//因此，头文件的内容被顺利的包含进来，同时，定义了该宏，如果此头文件被重复包含了，那么文件第一行的预处理指令将不会满足，因此文件也就不会被重复包含了。

int main()
{
    double circle = 2 * PI * 5;
    
    int ret1 = MUL(2,4);
    double ret2 = MUL(2.4, 4.3); 
    std::cout<< ret1<< ',' << ret2 << std::endl;
    int ret3 = MUL(2+3, 4); //此处的展开结果是 2 + 3 * 4, 和预期的（2 + 3） * 4 并不相同

    std::cin.get();
}